import React, {
  useState,
  useEffect,
  useRef,
  useMemo,
  useCallback,
} from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Image,
  ScrollView,
  Dimensions,
  StatusBar,
  TextInput,
  ActivityIndicator,
  Platform,
  PixelRatio,
} from "react-native";
import Animated, {
  Extrapolate,
  interpolate,
  useAnimatedStyle,
  useAnimatedScrollHandler,
  useSharedValue,
  useDerivedValue,
  withRepeat,
  withTiming,
  withSpring,
  Easing,
  runOnJS,
} from "react-native-reanimated";
import { Animated as RNAnimated } from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { useTheme } from "../../styles/theme";
import CustomIcon from "../../components/ui/CustomIcon";
import { createStylesWithDMSans } from "../../utils/fontUtils";
import { useAuth } from "../../hooks/useAuth";
import { useMealPlans } from "../../hooks/useMealPlans";
import tagService from "../../services/tagService";
import apiService from "../../services/api";
import { LinearGradient } from "expo-linear-gradient";
import * as Location from "expo-location";
import * as Haptics from "expo-haptics";
import { Svg, Path } from "react-native-svg";
import MaskedView from "@react-native-masked-view/masked-view";

const { width, height } = Dimensions.get("window");

// Responsive scaling utilities
const scale = (size) => {
  const pixelRatio = PixelRatio.get();
  const deviceScale = width / 375; // Base on iPhone X width

  // Android adjustment factor for varied DPI
  const androidFactor =
    Platform.OS === "android" ? Math.min(pixelRatio / 2, 1.2) : 1;

  return size * deviceScale * androidFactor;
};

const verticalScale = (size) => (height / 812) * size; // Base on iPhone X height
const moderateScale = (size, factor = 0.5) =>
  size + (scale(size) - size) * factor;

// Screen size categories
const isSmallScreen = width < 350;
const isMediumScreen = width >= 350 && width < 414;
const isLargeScreen = width >= 414;
const isTablet = width >= 768;
const isLandscape = width > height;

// Platform-specific status bar height
const statusBarHeight =
  Platform.OS === "android" ? StatusBar.currentHeight || 0 : 0;

// Responsive breakpoints
const getResponsiveValue = (small, medium, large, tablet = large) => {
  if (isTablet) return tablet;
  if (isLargeScreen) return large;
  if (isMediumScreen) return medium;
  return small;
};

// Android-specific responsive values
const getAndroidResponsiveValue = (small, medium, large, xlarge) => {
  if (Platform.OS === "android") {
    if (width < 360) return small;
    if (width < 400) return medium;
    if (width < 500) return large;
    return xlarge;
  }
  return getResponsiveValue(small, medium, large, xlarge);
};

// Shadow utility for cross-platform compatibility
const getShadowStyle = (shadowProps) => ({
  ...shadowProps,
  ...(Platform.OS === "android" && {
    elevation: shadowProps.shadowOpacity ? shadowProps.shadowOpacity * 10 : 5,
  }),
});

// Responsive dimensions - Smaller preview image
const heroImageSize = getResponsiveValue(220, 260, 300, 360);
const heroImageBorderRadius = heroImageSize / 2;
const previewImageSize = heroImageSize - 6; // Account for border
const previewImageBorderRadius = previewImageSize / 2;

// Circular carousel constants (responsive) - Larger items on bigger screens for better visibility
const ListItemWidth = getResponsiveValue(
  width / 4.5, // Smaller items on small screens
  width / 4, // Medium screens
  width / 3.2, // Large screens - increased size
  width / 4.5 // Tablets - increased size
);

// Clean Circular Carousel Implementation:
// - Based on animate-with-reanimated reference for maximum smoothness
// - Removed infinite scroll complexity for better performance
// - Direct data usage without circular array generation
// - Simple scroll handler matching reference implementation
// - Optimized preview image sync for simplified data structure

// Cache tags globally to avoid re-fetching on every render (same as TagFilterBar)
let cachedTags = [];
let tagsLastFetched = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// Export function to refresh tags cache (call when new tags are created)
export const refreshTagsCache = () => {
  cachedTags = [];
  tagsLastFetched = 0;
};

// Placeholder data with images
const PLACEHOLDER_PLANS = [
  {
    id: "placeholder-1",
    name: "FitFam",
    description: "Perfect for gym enthusiasts",
    image: require("../../../assets/authImage.png"),
    bigPreviewImage: require("../../../assets/authImage.png"),
  },
  {
    id: "placeholder-2",
    name: "HealthyChoice",
    description: "Balanced nutrition daily",
    image: require("../../../assets/authImage.png"),
    bigPreviewImage: require("../../../assets/authImage.png"),
  },
  {
    id: "placeholder-3",
    name: "PowerPlan",
    description: "High protein meals",
    image: require("../../../assets/authImage.png"),
    bigPreviewImage: require("../../../assets/authImage.png"),
  },
  {
    id: "placeholder-4",
    name: "GreenLife",
    description: "Fresh vegetables focus",
    image: require("../../../assets/authImage.png"),
    bigPreviewImage: require("../../../assets/authImage.png"),
  },
  {
    id: "placeholder-5",
    name: "ActiveLife",
    description: "Energy boosting meals",
    image: require("../../../assets/authImage.png"),
    bigPreviewImage: require("../../../assets/authImage.png"),
  },
];

const HomeScreen = ({ navigation }) => {
  const { colors, isDark } = useTheme();
  const { user } = useAuth();
  const { mealPlans } = useMealPlans();

  const flatListRef = useRef(null);
  const [tags, setTags] = useState(cachedTags || []);
  const [loading, setLoading] = useState((cachedTags || []).length === 0);
  const [currentLocation, setCurrentLocation] = useState(
    user?.address || "My Current Location"
  );
  const [isLoadingLocation, setIsLoadingLocation] = useState(false);

  // State for checking active subscription
  const [checkingSubscription, setCheckingSubscription] = useState(true);
  const [hasCheckedSubscription, setHasCheckedSubscription] = useState(false);

  // Pre-fetch duration data for focused tag
  const [prefetchedDurations, setPrefetchedDurations] = useState({});

  // Carousel state (simplified)
  const [previousDescription, setPreviousDescription] = useState("");

  // Circular reveal animation state (like reference animation)
  const circleAnimation = useRef(new RNAnimated.Value(0)).current;

  // Shared values for all animations (eliminate state-based race conditions)
  const contentOffset = useSharedValue(0);
  const spinValue = useSharedValue(0);
  const descriptionOpacity = useSharedValue(1);

  // Animation shared values for hero transitions
  const heroImageScale = useSharedValue(1);
  const heroImageOpacity = useSharedValue(1);
  const badgeScale = useSharedValue(1);
  const badgeOpacity = useSharedValue(1);
  const descriptionTranslateY = useSharedValue(0);

  // Text rotation messages
  const heroMessages = [
    "Eat healthy!",
    "Save Money!",
    "Stay Fresh!",
    "Live Better!",
  ];

  const [currentMessageIndex, setCurrentMessageIndex] = useState(0);

  // Check for active subscription and navigate to TodayMeal
  useEffect(() => {
    const checkActiveSubscription = async () => {
      // Only check once per session
      if (hasCheckedSubscription) {
        console.log("‚ÑπÔ∏è Already checked subscription, skipping");
        return;
      }

      try {
        console.log("üîç Checking for active subscription...");
        setCheckingSubscription(true);

        // Ensure token is loaded before making API call
        await apiService.getStoredToken();

        // STRATEGY: Call getUserDashboardData API directly (more reliable)
        console.log("üìû Calling getUserDashboardData API...");
        const subscriptionsResult = await apiService.getUserDashboardData();
        console.log(
          "üì¶ Dashboard API response:",
          JSON.stringify(subscriptionsResult, null, 2)
        );

        // Handle 401 errors (no token)
        if (
          subscriptionsResult?.status === 401 ||
          subscriptionsResult?.error === "No token provided"
        ) {
          console.log("‚ö†Ô∏è No valid token, staying on Home screen");
          setCheckingSubscription(false);
          return;
        }

        // ‚ú® NEW: Extract data from unified endpoint response
        if (subscriptionsResult?.success && subscriptionsResult?.data) {
          const data = subscriptionsResult.data;

          console.log("üìä Unified dashboard data:", {
            hasActiveSubscription: data.hasActiveSubscription,
            hasSubscription: !!data.activeSubscription,
          });

          if (data.hasActiveSubscription && data.activeSubscription) {
